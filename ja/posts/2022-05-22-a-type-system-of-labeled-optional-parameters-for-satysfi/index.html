<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/bootstrap.min.css><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/style.css><title>gfnweb | SATySFi v0.1.0に向けたラベルつきオプション引数の型システム</title></head><body class="d-flex flex-column" style=min-height:100vh><nav id=nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class=container-fluid><a class=navbar-brand href=https://gfngfn.github.io/ja/>gfnweb</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class=nav-item><a class=nav-link href=/ja/><i data-feather=home></i>
Home</a></li><li class=nav-item><a class=nav-link href=/ja/about/><i data-feather=user></i>
About</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i data-feather=file-text></i>Language</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=https://gfngfn.github.io/posts/2022-05-22-a-type-system-of-labeled-optional-parameters-for-satysfi/>English</a></li><li><span class="dropdown-item disabled">日本語</span></li></ul></li></ul></div></div></nav><main class="mb-auto pb-5"><div class="jumbotron bg-light upcards-single-heading"><div class="mx-auto upcards-single-board"><h1 class=upcards-single-board-title>SATySFi v0.1.0に向けたラベルつきオプション引数の型システム</h1><div class=upcards-time-section><p class=upcards-time><time datetime=2022-05-22>2022年5月22日</time></p></div><div><span style=position:relative;z-index:2><a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/ja/tags/%E8%A8%98%E4%BA%8B>記事</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/ja/tags/satysfi>SATySFi</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/ja/tags/%E5%9E%8B%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0>型システム</a></span></div></div></div><div class=upcards-single-content><div class="mx-auto upcards-single-board"><p>SATySFi v0.1.0に向けてオプション引数に関する言語設計を非互換に改めつつあるので，その紹介をします．</p><p>初出：</p><ul><li>2021年12月30日，<a href=https://github.com/gfngfn/SATySFi/wiki/%E3%83%A9%E3%83%99%E3%83%AB%E3%81%A4%E3%81%8D%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E5%BC%95%E6%95%B0%E3%81%AE%E5%9E%8B%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0>SATySFi Wiki</a></li></ul><h2 id=改造の動機>改造の動機</h2><p>もともとSATySFi v0.0.xにもラベルなしオプション引数の機構は存在していて，以下のように <code>?:</code> で与えることができました：</p><pre tabindex=0><code>+section?:(`sec:sample`)?:(`Sample`){Sample}&lt;
 （章の本文）
&gt;
</code></pre><p>オプション引数にはラベルはなく，オプション引数列のうちで何番目に与えられたかによって識別されていました．上記の例だと，1番目のオプション引数は相互参照のための識別文字列であり，2番目のオプション引数はPDFのアウトラインでこの章のタイトルとしてどのような文字列を出すかの指定です．コマンドだけでなく，通常の函数でもオプション引数をとることができます：</p><pre tabindex=0><code>let succ ?diff-opt n =
  match diff-opt with
  | Some(d) -&gt; n + d
  | None    -&gt; n + 1
in
(succ 42, succ ?:57 42)
  % --&gt; (43, 99)
</code></pre><p>オプション引数がラベルをもたないような言語設計にしたのは，主にLaTeXでラベルなしのオプション引数に相当するようなインターフェイスが慣習的によく使われていることに触発されたものでした：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-latex data-lang=latex><span style=display:flex><span><span style=color:#66d9ef>\parbox</span><span style=color:#a6e22e>[c]</span>{6em}{…}, <span style=color:#e6db74>$</span>\sqrt<span style=color:#f92672>[</span><span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>{<span style=color:#ae81ff>2</span>}<span style=color:#e6db74>$</span>
</span></span></code></pre></div><p>しかし，オプション引数を使いたくなる場面は当初の言語設計時の想定より多かったこともあり，以下のような不便さが顕著に生じました：</p><ul><li>順番で識別する仕組みだと，どの指定を何番目にすべきかが読み書きするときに解りづらいことが多い．</li><li>オプション引数の列の中でより手前のものを省略し後方のものを与えるときは，手前のものを <code>?*</code> で “明示的に省略” する必要があり，面倒である．<ul><li>例えば以下のような具合：<pre tabindex=0><code>+section?*?:(`Sample`){Sample}&lt;
 （章の本文）
&gt;
</code></pre></li></ul></li></ul><p>こうした面倒さを解消するために，オプション引数をラベルつきの定式化に変え，以下のように書けるようにしたいと考えました：</p><pre tabindex=0><code>+section?(ref = `sec:sample`, outline = `Sample`){Sample}&lt;
 （章の本文）
&gt;
</code></pre><p>見ての通り，オプション引数部分を <code>?(label1 = arg1, …, labelN = argN)</code> の形で記述します．オプション引数をひとつも指定しない場合は，<code>?(…)</code> 全体を省けます．通常の函数も以下のように定義・使用できます：</p><pre tabindex=0><code>let succ ?(diff = diff-opt) n =
  match diff-opt with
  | Some(d) -&gt; n + d
  | None    -&gt; n + 1
  end
in
(succ 42, succ ?(diff = 57) 42)
</code></pre><p>この定式化には以下のような恩恵があります：</p><ul><li>引数にラベル名がつくので，単純に何に関する指定なのかが解りやすい．</li><li>各引数の与え方は順不同なので，一部を省略する場合も <code>?*</code> のようなぎこちない方法をとる必要がない．</li><li>相変わらず静的に型がつき，想定していないラベル名を指定した場合や引数の型がおかしい場合は型エラーが出てくれる．</li></ul><p>デフォルト値を与える場合は，もう少し簡潔に以下のようにも書けるようにするつもりです：</p><pre tabindex=0><code>let succ ?(diff = d = 1) n =
  n + d
in
(succ 42, succ ?(diff = 57) 42)
</code></pre><h2 id=型システムの詳細>型システムの詳細</h2><h3 id=函数型函数抽象函数適用の拡張>函数型・函数抽象・函数適用の拡張</h3><p>型の構文としては，函数型が通常の <code>τ -> τ</code> から以下のように拡張されます：</p><pre tabindex=0><code>τ ::=
  …
  | ?(l : τ, …, l : τ) τ -&gt; τ
</code></pre><p>本当はもう少し一般性の高い形式であることを後で説明しますが，今はひとまずこの素直な形であると把握していてください．</p><p>（ちなみに従来のラベルなしオプション引数の場合は <code>τ ?-> … τ ?-> τ -> τ</code> の形でした．）</p><p>函数抽象と函数適用の構文も（型註釈をつけてよいことや糖衣構文を簡単のため省略すると）以下のように拡張されます：</p><pre tabindex=0><code>e ::=
  …
  | fun ?(l = x, …, l = x) x -&gt; e
  | e ?(l = e, …, l = e) e
</code></pre><p>函数適用の型つけ規則は以下のように単純です：</p><pre tabindex=0><code>Γ, x_1 : option τ_1, …, x_n : option τ_n, x : τ&#39; ⊢ e : τ
-----------------------------------------------------------------------------
Γ ⊢ fun ?(l_1 = x_1, …, l_n = x_n) x -&gt; e : ?(l_1 : τ_1, …, l_n : τ_n) τ&#39; -&gt; τ
</code></pre><p>“変数はそれぞれ函数抽象の内側からは <code>τ_i</code> 型ではなく <code>option τ_i</code> 型に見える” ことだけ注意が必要ですが，基本的にはとても素直な規則です．</p><p>函数適用の規則も記述が若干ややこしいですが意味するところはわりと素直です：</p><pre tabindex=0><code>Γ ⊢ e : ?(l_1 : τ_1, …, l_n : τ_n) τ&#39; -&gt; τ
Γ ⊢ e_k : τ_(j_k)  (for each k ∈ {1, …, m})
Γ ⊢ e&#39; : τ&#39;
-----------------------------------------------
Γ ⊢ e ?(l_(j_1) = e_1, …, l_(j_m) = e_m) e&#39; : τ
</code></pre><h3 id=多相性>多相性</h3><p>基本的には前節で変更の概要はお伝えできたかと思いますが，実際には多少技巧的な工夫があり，或る種の多相性が実現されています．</p><p>多相性の必要性については，例えば次の例を考えるとわかりやすいです： 以下のような高階函数にはどんな型がつくべきでしょうか？</p><pre tabindex=0><code>let use_optional(f) = f ?(foo = 42, 57) + 1
</code></pre><p>とりわけ，引数の <code>f</code> にはどんな型がつくべきでしょうか？ <code>?(foo : int) int -> int</code> のような型を想定するかもしれませんが，例えば “<code>foo</code> のほかに <code>bar</code> のようなオプション引数も受け取れて，ここでは単に <code>foo</code> しか与えられていないだけ” という函数も <code>f</code> として適格なはずです．こうしたことを表現するためにオプション引数に関する多相性が必要になってきます．</p><p>こうした多相性を表現するために，SATySFi v0.1.xのオプション引数では <strong>列多相</strong> の一種 [1] を転用することにしました．オプション引数について同様の仕組みをとっている論文や実装を見たことがないためおそらく筆者の考案によるものだと思いますが，仕組みとしてはシンプルであってわりとすぐ思いつくようなものです（ただし，おそらく大丈夫だろうとは思っているものの型安全性などの正当性を既に証明しているわけではないです）．</p><p>これは直観としては1つの函数のとるオプション引数全体を <strong>列</strong> (<em>row</em>)とみなすという方法です．列は一般的にはレコードの型つけに使う機構ですが，これをオプション引数の型つけにも転用し，函数の型は以下のような構文であると考えます：</p><pre tabindex=0><code>τ ::=
  …
  | ?(r) τ -&gt; τ

r ::=
  | l : τ, r
  | *
  | ρ
</code></pre><p><code>r</code> が列のメタ変数であり，<code>ρ</code> が <strong>列変数</strong> (<em>row variable</em>)全体を動くメタ変数です．<code>*</code> は空の列を，<code>l : τ, r</code> は列 <code>r</code> に <code>l : τ</code> を追加してできる列を表します．最初に掲げた函数型の拡張 <code>?(l_1 : τ_1, …, l_n : τ_n) τ' -> τ</code> は，実際には <code>?(…)</code> の内側が <code>l_1 : τ_1, …, l_n : τ_n, *</code> という列であったという一般化です．</p><p>こうした仕組みを使うと，前述の <code>use_optional</code> には以下のように型をつけることができます：</p><pre tabindex=0><code>use_optional : ∀ρ :: Row {foo}. ?(foo : int, ρ) int -&gt; int
</code></pre><p>ただし，ラベル集合 <code>L</code> に対して <code>Row L</code> は “<code>L</code> の元のラベルを含まない列につくカインド” です．すなわち，上記の型での全称量化は “<code>ρ</code> が <code>foo</code> をもたない列全体を動く” ということを意味します．こうして <code>use_optional</code> の第1引数 <code>f</code> には “<code>int</code> 型のオプション引数をラベル <code>foo</code> で受け取れるが，それ以外のオプション引数については自由であるような函数” と扱うことができます．</p><p>こうした仕組みは既に<a href=https://github.com/gfngfn/SATySFi/pull/294>v0.1.0に向けた実装</a>ではおおよそ実現されており，少なくともいくらかの例に於いては問題なく使用できています．</p><h2 id=まとめ>まとめ</h2><p>本稿ではSATySFi v0.1.xに向けて設計・実装したラベルつきオプション引数の仕組みについて概説し，それが列多相をベースとして実現した機構であることを紹介しました．</p><h2 id=参考文献>参考文献</h2><ol><li>Benedict R. Gaster and Mark P. Jones. <a href=https://web.cecs.pdx.edu/~mpj/pubs/96-3.pdf>A polymorphic type system for extensible records and variants</a>, 1996.</li></ol></div></div></main><footer class="footer py-3 bg-light"><p class="footer text-center">(c) 2022 Copyright: T. Suwa</p></footer><script src=https://gfngfn.github.io/js/bootstrap.bundle.min.js></script>
<script src=https://gfngfn.github.io/js/masonry.pkgd.min.js></script>
<script src=https://gfngfn.github.io/js/feather.min.js></script>
<script>feather.replace()</script><script>window.addEventListener("load",function(){var t,e=document.getElementById("grid");e!==null&&(t=new Masonry(e,{itemSelector:".upcards-grid-item",horizontalOrder:!0,fitWidth:!0,gutter:0}))})</script></body></html>