<!doctype html><html lang=ja><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/bootstrap.min.css><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/style.css><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/chroma.css><title>SATySFi 0.1.0の新しいエコシステムSapheのプロトタイプについて（前編） - gfnweb</title></head><body class="d-flex flex-column" style=min-height:100vh><nav id=nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class=container-fluid><a class=navbar-brand href=https://gfngfn.github.io/ja/>gfnweb</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class=nav-item><a class=nav-link href=/ja/><i data-feather=home></i>
Home</a></li><li class=nav-item><a class=nav-link href=/ja/about/><i data-feather=user></i>
Profile</a></li><li class=nav-item><a class=nav-link href=https://github.com/gfngfn><i data-feather=github></i>
GitHub</a></li><li class=nav-item><a class=nav-link href=https://twitter.com/bd_gfngfn><i data-feather=twitter></i>
Twitter/X</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i data-feather=file-text></i>Language</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=https://gfngfn.github.io/posts/2024-01-15-saphe-a-new-prototype-ecosystem-for-satysfi-the-first-half/>English</a></li><li><span class="dropdown-item disabled">日本語</span></li></ul></li></ul></div></div></nav><main class="mb-auto pb-5"><div id=articleHeading class="jumbotron bg-light upcards-single-heading"><div class="mx-auto upcards-single-board"><h1 class=upcards-single-board-title>SATySFi 0.1.0の新しいエコシステムSapheのプロトタイプについて（前編）</h1><div class=upcards-time-section><p class=upcards-time><time datetime=2024-01-15>2024年1月15日</time></p></div><div><span style=position:relative;z-index:2><a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/ja/tags/article>記事</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/ja/tags/satysfi>SATySFi</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/ja/tags/programming-language>プログラミング言語</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/ja/tags/typesetting>組版</a></span></div><div class=mt-3><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class=twitter-share-button data-show-count=false>Tweet</a></div></div></div><div class=upcards-single-content><div class="mx-auto upcards-single-board"><p>昨年のSATySFi Conf 2023で発表させてもらった，SATySFi 0.1.0に向けたエコシステム <strong>Saphe</strong>（セイフ）について，設計とプロトタイプ実装が固まってきたため，そのおおよその仕組みを共有しようと思います．発表の内容とも一部オーバーラップします．</p><p>前編である本稿は，Sapheがどのように使えるツールなのかをハンズオン的に記載します．後編はSapheの詳細な設計・実装について述べる予定です．</p><p>本稿執筆時点でのSapheの実装は，以下のPRの <a href=https://github.com/gfngfn/SATySFi/pull/422/commits/44ff21be6ffb3675512f0599d5d139809f7c5786><code>44ff21b</code></a> です：</p><ul><li><a href=https://github.com/gfngfn/SATySFi/pull/422>Separate <code>saphe</code> from <code>satysfi</code> by gfngfn · Pull Request #422 · gfngfn/SATySFi</a></li></ul><div id=toc class="upcards-toc px-3"><h3 class=mt-0>目次</h3><nav id=TableOfContents><ul><li><a href=#sapheの役割>Sapheの役割</a></li><li><a href=#なぜ新しいエコシステムが必要だったか>なぜ新しいエコシステムが必要だったか</a></li><li><a href=#サブコマンド>サブコマンド</a></li><li><a href=#文書を組みたい場合のsapheの使い方>文書を組みたい場合のSapheの使い方</a><ul><li><a href=#1-初期化>1. 初期化</a></li><li><a href=#2-パッケージの依存解決>2. パッケージの依存解決</a></li><li><a href=#3-文書を組む>3. 文書を組む</a></li><li><a href=#used_as-とは何なのか><code>used_as</code> とは何なのか</a></li></ul></li><li><a href=#ライブラリを実装したい場合のsapheの使い方>ライブラリを実装したい場合のSapheの使い方</a><ul><li><a href=#1-初期化-1>1. 初期化</a></li><li><a href=#2-パッケージの依存解決-1>2. パッケージの依存解決</a></li><li><a href=#3-型検査を走らせる>3. 型検査を走らせる</a></li><li><a href=#4-テストを走らせる>4. テストを走らせる</a></li></ul></li><li><a href=#まとめ>まとめ</a></li></ul></nav></div><h2 id=sapheの役割>Sapheの役割</h2><p>Saphe（SATySFi Package-Handling Ecosystem，/seɪf/ と発音）は，簡単に言えばSATySFiのためのパッケージマネージャとビルドシステムが複合したものです．具体的には，以下のようなことを円滑に行なうためのソフトウェアです：</p><ol><li>ユーザが<strong>コンフィグファイル</strong>によって指定した依存パッケージたちを<strong>パッケージレジストリ</strong>と呼ばれる集積所から取得し，ユーザのマシンで使えるようにする．<ul><li>この過程で，依存制約を充足するように，各々のパッケージに対して適切なバージョンを選択する必要がある．同一パッケージの異なるバージョン間の互換性はバージョン番号によって判別できるようになっており，共存できる組み合わせがある場合はそのうちの1つを選ぶ<strong>依存解決</strong>を行なう．</li></ul></li><li>文書組版の再現性を担保する．<ul><li>主にこの目的のために，依存解決の結果は<strong>ロックファイル</strong>に出力される．ロックファイルもバージョン管理に含めるのが望ましい．</li></ul></li><li>取得したパッケージを，SATySFiで文書を組むのに使ったり，または更にそれらに依存するパッケージを実装するのに使う．</li></ol><p>すなわち，SATySFiに於けるSapheは，Rustに対する<strong>Cargo</strong>や，Haskellに対する<strong>Cabal</strong>または<strong>Stack</strong>に相当する機構です．</p><h2 id=なぜ新しいエコシステムが必要だったか>なぜ新しいエコシステムが必要だったか</h2><p>SATySFi 0.0.xには，既に<strong>Satyrographos</strong>というデファクトスタンダードのエコシステムがあります．そのため，Satyrographosを拡張した上でSATySFi 0.1.0に関しても継続して使うという選択肢もあります．では，Sapheを新たに設計・実装する必要性はどこから生じたのでしょうか？ それは，SATySFi 0.0.xがしばらく使われるうちに顕在化してきた以下のような課題です：</p><ul><li>依存関係ゆえに<strong>同一パッケージの複数のバージョンを共存させざるを得ない状況が生じることがあるが，こうした共存は現行のエコシステムではかなり回りくどい方法でしか実現できない</strong>．また，SATySFi 0.0.x本体の言語設計に於いても，同一パッケージの複数バージョンが共存処理するためには同一の名前のモジュールが共存できる必要があるが，実現可能ながらも筋の良い方法ではなく，制御が難しい．</li><li>任意の文字列がバージョン番号に指定でき，また後方互換性の判定もバージョンによって自動化されたりはしていないため，<strong>互換性の記述がパッケージ作成者の気づかいや技量に大きく依存している</strong>．</li></ul><p>SATySFi処理系本体の問題点を差し引くと，これらの課題を生じる原因は実は共通しています： Satyrographosがパッケージ管理に関して<strong>OPAM</strong>というOCamlやCoq向けのパッケージマネージャに依存していることです．したがって，これらの課題を解消するには，以下のような改修が望ましそうです：</p><ul><li>SATySFi本体の言語設計を，同一パッケージの複数バージョン共存などにも堪えうる筋の良いものに修正する</li><li>Satyrographosの設計・実装をOPAMに依存しないものにする</li></ul><p>実際，前者がSATySFi 0.1.0を開発している目的の1つでもあるわけです．しかしながら，後者のSatyrographosの改修にはやや障壁がありました：</p><ul><li>Satyrographosの作者であるSakamotoさんが本業でかなり多忙になられており，大規模な改修の労力を捻出してもらうのは難しそうだった</li><li>そもそも<strong>複数バージョン共存なども要件に含めるとSatyrographosとSATySFi 0.1.0の間での責務分担はかなり非自明</strong>であり，Sakamotoさんと相談しながら分担して開発を行なうにしても取っ掛かりが掴めなかった</li><li>一方で，私自身がSatyrographosの既存のコードベースに大幅に手を加えて0.0.x向けの機能を壊さないように0.1.0向けの機能を追加するのは労力的に割に合いそうにないと感じた</li></ul><p>そこで，<strong>SATySFiを改築しつつエコシステムのプロトタイプを同時にゼロから構築していき，適宜それぞれの設計を修正することで責務分担の吟味を1人で反復するのが早かろうと考え，まずはそうしたプロトタイプであるSapheをつくることにした</strong>，という次第です．2024年1月の現時点でSapheはあくまでもプロトタイプ実装として位置づけており，将来的にも現状の形式をとり続けるか，または相談の上でSatyrographosに一部分として取り込んでもらうことになるかなどは未定ですが，実用に耐えるくらいには実際に動作するものになりました．</p><h2 id=サブコマンド>サブコマンド</h2><p>現在のところ，以下の5つのサブコマンドがあります：</p><ul><li><code>$ saphe init [document|library] &lt;file-path></code>：<ul><li>プロジェクト（文書またはパッケージ）を初期化する．</li></ul></li><li><code>$ saphe solve &lt;file-path></code><ul><li>パッケージの依存解決を行ない，ロックファイルを生成・更新する．</li></ul></li><li><code>$ saphe update &lt;file-path></code><ul><li>パッケージレジストリの情報を最新のものに更新する．</li></ul></li><li><code>$ saphe build &lt;file-path></code><ul><li>文書を組む，またはライブラリを検査する．</li></ul></li><li><code>$ saphe test &lt;file-path></code><ul><li>ライブラリのテストを実行する．</li></ul></li></ul><p><code>update</code> の解説は後編に譲りますが，他のコマンドは本稿の以下の章でハンズオン的に紹介します．</p><h2 id=文書を組みたい場合のsapheの使い方>文書を組みたい場合のSapheの使い方</h2><h3 id=1-初期化>1. 初期化</h3><p>カレントディレクトリ（以下 <code>/path/to</code> とします）に <code>foo.saty</code> という文書をつくって書き始めたいとします．この場合，まず以下を実行してファイルの雛形を生成します：</p><div class=upcards-console-block><pre><code>$ saphe init document foo.saty
  created a package config '/path/to/foo.saphe.yaml'
  created '/path/to/foo.saty'</code></pre></div><p>以下のような2つのファイルが生成されました．</p><div class=upcards-code-block><pre><code>.
├── foo.saphe.yaml
└── foo.saty</code></pre></div><p><code>foo.saty</code> が文書本体，<code>foo.saphe.yaml</code> が<strong>コンフィグファイル</strong>です．文書本体 <code>foo.saty</code> は以下のような内容で生成されています：</p><div class=upcards-code-block><pre><code>use package open StdJaReport

document (|
  title = {The Title of Your Document},
  author = {Your Name},
|) '<
  +chapter{First Chapter}<
    +p{
      Hello, world!
    }
  >
></code></pre></div><p>従来のSATySFi 0.0.xに馴染んでいるユーザからすると，1行目の <code>use package …</code> が目新しいほか，注意深く見るとレコード <code>(| … |)</code> の内容がセミコロン <code>;</code> ではなくコンマ <code>,</code> で区切られていたりしますが，基本的にはほぼ見覚えのあるファイルですね．</p><p>コンフィグファイル <code>foo.saphe.yaml</code> は以下のような内容です：</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>ecosystem</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^0.0.1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>language</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^0.1.0&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;your-document&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>authors</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=s2>&#34;Your Name&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>registries</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>git</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>url</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;https://github.com/SATySFi/default-registry&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>branch</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;temp-dev-saphe&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>contents</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>document</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>dependencies</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>used_as</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;StdJaReport&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>registered</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>registry</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;std-ja-report&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>requirement</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^0.0.1&#34;</span></span></span></code></pre></div></div><p>CargoやCabalを使ったことがある人なら，なんとなく各部分が何を指定しているか想像できるかもしれません．<code>ecosystem</code> には想定するSapheのバージョンを，<code>language</code> には想定するSATySFi本体のバージョンを，それぞれ指定します．Sapheはコンフィグファイルを読むときにまず <code>ecosystem</code> を見て，自身がそのコンフィグファイルを適切に処理できる（とユーザが考えている）ことを確認します．<code>^0.0.1</code> は「<code>0.0.1</code> またはそれに後方互換なバージョン」を指す記述です．バージョン番号は基本的には<strong>Semantic Versioning</strong>に準拠してつけますが，Sapheはバージョン番号のつけ方に追加で制約を要請します： メジャーバージョンが <code>0</code> の場合，マイナーバージョンを保ったままパッチバージョンを加算する更新は，後方互換なリリースであるとみなします（これはCargoが採用している方針と共通しています）．</p><p><code>name</code> および <code>authors</code> は現状必須のフィールドながら文書では特に実用上の用途がありません．後述のライブラリ作成では意味をもつフィールドですが，文書の場合はひとまず文書名と著者リストで埋めておいてください．</p><p><code>registries</code> はパッケージレジストリを指定する箇所です．基本的にはここをいじる機会は少なく，生成された記述をずっと使うのが典型的であろうと思います．社内ライブラリなど，一般には公開しないパッケージを集積するパッケージレジストリを社内ネットワークに用意したい場合は，ここに追記することになります．</p><p><code>dependencies</code> には依存パッケージの指定が入ります．典型的なユーザが最もいじる箇所はこの部分であろうと思います．初期値では「<code>std-ja-report</code> パッケージの <code>0.0.1</code> またはそれに後方互換なバージョン」が依存パッケージとして指定されています．ここで書かれている <code>used_as</code> がSapheでの特徴的な指定なのですが，これについては後述します．</p><h3 id=2-パッケージの依存解決>2. パッケージの依存解決</h3><p>さて，この文書を組むには，まずはパッケージレジストリのデータをもとに依存パッケージの依存関係を辿って必要なパッケージとそのバージョンを決定し，必要なものを取得する必要があります．これを行なうのが <code>solve</code> サブコマンドです：</p><div class=upcards-console-block><pre><code>$ saphe solve foo.saty
  package dependencies to solve:
  - std-ja-report (^0.0.1) used as StdJaReport
  package dependency solutions:
  - annot 0.0.1
  - code 0.0.1
  - font-ipa-ex 0.0.1
  - font-junicode 0.0.1
  - font-latin-modern 0.0.1
  - font-latin-modern-math 0.0.1
  - footnote-scheme 0.0.1
  - math 0.0.1
  - std-ja-report 0.0.1
  - stdlib 0.0.1
（中略．取得処理が並ぶ）
  lock config written on '/path/to/foo.saphe.lock.yaml'.</code></pre></div><p>依存パッケージは <code>std-ja-report</code> ただ1つでしたが，<code>std-ja-report</code> を介して間接依存するパッケージも全部かき集められて取得され，その結果が<strong>ロックファイル</strong> <code>foo.saphe.lock.yaml</code> に書き出されました．</p><div class=upcards-code-block><pre><code>.
├── foo.saphe.lock.yaml
├── foo.saphe.yaml
└── foo.saty</code></pre></div><p><div><img src=/media/saphe-a-new-prototype-ecosystem-for-satysfi-1.png alt="saphe solveの動作の概略図" style=max-width:100%></div></p><p>生成されたロックファイル <code>foo.saphe.lock.yaml</code> は，ユーザが中身を読み書きすることは全くありませんが，処理の再現性のために，Gitなどによるバージョン管理には含めるのが望ましいものです．</p><h3 id=3-文書を組む>3. 文書を組む</h3><p>さて，いよいよ文書を組む準備ができたので，実際に文書を組みます．</p><div class=upcards-console-block><pre><code>$ saphe build foo.saty
  deps file: '/path/to/foo.satysfi-deps.yaml'
 ---- ---- ---- ----
  target file: '/path/to/foo.pdf'
  dump file: '/path/to/foo.satysfi-aux' (will be created)
  parsing '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/annot/annot.0.0.1/src/annot.satyh' ...
（中略）
  parsing '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/stdlib/stdlib.0.0.1/src/hdecoset.satyh' ...
 ---- ---- ---- ----
  type checking '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/stdlib/stdlib.0.0.1/src/option.satyg' ...
  type check passed.
（中略）
  type checking '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/std-ja-report/std-ja-report.0.0.1/src/std-ja-report.satyh' ...
  type check passed.
  parsing '/path/to/foo.saty' ...
 ---- ---- ---- ----
  type checking '/path/to/foo.saty' ...
  type check passed. (document)
  preprocessing '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/stdlib/stdlib.0.0.1/src/option.satyg' ...
（中略）
  preprocessing '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/std-ja-report/std-ja-report.0.0.1/src/std-ja-report.satyh' ...
  evaluating '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/stdlib/stdlib.0.0.1/src/option.satyg' ...
（中略）
  evaluating '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/std-ja-report/std-ja-report.0.0.1/src/std-ja-report.satyh' ...
 ---- ---- ---- ----
  evaluating texts ...
modified version of stdjareport.
  evaluation done.
 ---- ---- ---- ----
  breaking contents into pages ...
（中略）
  all cross references were solved.
 ---- ---- ---- ----
  embedding fonts ...
 ---- ---- ---- ----
  writing pages ...
 ---- ---- ---- ----
  output written on '/path/to/foo.pdf'.
  deps config written on '/path/to/foo.satysfi-deps.yaml'.</code></pre></div><p>随分と色々うるさく標準出力に出ますが，最終的に無事 <code>foo.pdf</code> が生成できています．開いて見てみましょう：</p><p><div><img src=/media/saphe-a-new-prototype-ecosystem-for-satysfi-2.png alt=出力された文書の画像 style=max-width:100%></div></p><p>組めていますね．やったぜ．</p><p>実は，<code>saphe build</code> はPDF以外にも若干ファイルを生成します．最終的には以下のようになっているはずです：</p><div class=upcards-code-block><pre><code>.
├── foo.pdf
├── foo.saphe.lock.yaml
├── foo.saphe.yaml
├── foo.saty
├── foo.satysfi-aux
└── foo.satysfi-deps.yaml</code></pre></div><p><code>foo.satysfi-aux</code> はSATySFi本体が組版処理中に出力したファイルで，0.0.x時代からある相互参照の<strong>ダンプファイル</strong>です（TeX/LaTeXでいうところの <code>.aux</code> と等価なもの）．もう一方の <code>foo.satysfi-deps.yaml</code> は，SATySFi本体を起動する前にSapheがロックファイル <code>foo.saphe.lock.yaml</code> をもとに生成し，依存パッケージの配置や読み込むべき順序などをSATySFi本体に伝えるためのファイルで，そのまま<strong>satysfi-depsファイル</strong>と呼んでいます．これら2つはバージョン管理から除外すべきファイルです．<code>$saphe build</code> の動作を図にまとめると以下のような具合になります：</p><p><div><img src=/media/saphe-a-new-prototype-ecosystem-for-satysfi-3.png alt="saphe buildの動作の概略図" style=max-width:100%></div></p><p>こうして <code>$ saphe init</code>，<code>$ saphe solve</code>，<code>$ saphe build</code> の3コマンドで文書が組めるようになっているわけです．</p><h3 id=used_as-とは何なのか><code>used_as</code> とは何なのか</h3><p><code>used_as</code> は，簡単に言えば「そのパッケージがどのようなモジュール名でプロジェクト中の <code>use package …</code> で参照されるか」を指定する箇所です．</p><p>もう少し前提から紹介すると，SATySFi 0.1.xおよびSapheでは「各パッケージは<strong>メインモジュール</strong>と呼ばれるただ1つのモジュールだけを公開する」という仕組みがとられています．例えばパッケージ <code>stdlib</code> は <code>Stdlib</code> をメインモジュールとし，このモジュールの入れ子のメンバとして <code>Stdlib.Option</code>，<code>Stdlib.List</code> などのモジュールを提供するという具合です．</p><p>このメインモジュールの名前は，使う側がコンフィグファイル中で指定して替えられるようになっています．その指定を行なう箇所が <code>used_as</code> だったというわけです．ためしに先ほどの例の <code>used_as</code> を変更して処理してみましょう：</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl>     dependencies:
</span></span><span class=line><span class=cl><span class=gd>-      - used_as: &#34;StdJaReport&#34;
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+      - used_as: &#34;FooBar&#34;
</span></span></span><span class=line><span class=cl><span class=gi></span>         registered:
</span></span><span class=line><span class=cl>           registry: &#34;default&#34;
</span></span><span class=line><span class=cl>           name: &#34;std-ja-report&#34;
</span></span><span class=line><span class=cl>           requirement: &#34;^0.0.1&#34;
</span></span></code></pre></div></div><div class=upcards-console-block><pre><code>$ saphe solve foo.saty
（中略）
  lock config written on '/path/to/foo.saphe.lock.yaml'.
$ saphe build foo.saty
（中略）
  parsing '/path/to/foo.saty' ...
! [Error] at "foo.saty", line 1, characters 17-28:
    dependency on unknown package 'StdJaReport'</code></pre></div><p><code>StdJaReport</code> が知らないものとして弾かれました．文書の方も合わせて修正して処理してみましょう：</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gd>- use package open StdJaReport
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+ use package open FooBar
</span></span></span></code></pre></div></div><div class=upcards-console-block><pre><code>$ saphe build foo.saty
（中略）
  output written on '/path/to/foo.pdf'.</code></pre></div><p>処理できました．このように，<code>used_as</code> で依存パッケージをどのように参照するかが指定できるようになっています．</p><p>とはいえ，現実的にはこの <code>used_as</code> に指定するモジュール名としてはパッケージ名をcapitalizeしたものを書けば事足りることがほとんどです．上記の例でも <code>std-ja-report</code> をcapitalizeした <code>StdJaReport</code> を指定しているだけでしたし，<code>FooBar</code> のような別名にするとわかりにくいため積極的に変える理由はありません．ではなぜこんな仕組みがあるのかというと，同一パッケージの異なるバージョンが共存する際にこのような名前の変更が必要となるためです．</p><p>例えば，<code>base</code> パッケージの <code>1.x.y</code> と <code>2.x.y</code> を両方使わねばならない場面があるとしましょう．何もなければ両方使う必要が生じることはまずありませんが，例えば依存パッケージAとBがそれぞれ <code>base</code> の <code>1.x.y</code> と <code>2.x.y</code> のみに依存していて，両方必要になることがありえます．このとき，<code>used_as</code> を使うと両者を <code>BaseOld</code>，<code>Base</code> などと参照し分けることができます：</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>    </span><span class=nt>dependencies</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>used_as</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;BaseOld&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>registered</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>registry</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;base&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>requirement</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^1.0.0&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>used_as</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Base&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>registered</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>registry</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;base&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>requirement</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^2.0.0&#34;</span></span></span></code></pre></div></div><p>この <code>used_as</code> という機構によって，同一パッケージの複数の非互換なバージョンの共存が許容できる仕組みになっています．</p><h2 id=ライブラリを実装したい場合のsapheの使い方>ライブラリを実装したい場合のSapheの使い方</h2><h3 id=1-初期化-1>1. 初期化</h3><p>ライブラリの実装を始めたいときは，以下のように初期化します：</p><div class=upcards-console-block><pre><code>$ saphe init library .
  created a package config '/path/to/saphe.yaml'
  created '/path/to/src/Calc.satyh'
  created '/path/to/test/CalcTest.satyh'</code></pre></div><p>以下のようなファイルができました．</p><div class=upcards-code-block><pre><code>.
├── saphe.yaml
├── src
│   └── Calc.satyh
└── test
    └── CalcTest.satyh</code></pre></div><p>コンフィグファイル <code>saphe.yaml</code> は以下のような内容です：</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>ecosystem</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^0.0.1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>language</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^0.1.0&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;your-library&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>authors</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=s2>&#34;Your Name&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>registries</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>git</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>url</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;https://github.com/SATySFi/default-registry&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>branch</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;temp-dev-saphe&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>contents</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>library</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>main_module</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Calc&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>source_directories</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=s2>&#34;./src&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>test_directories</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=s2>&#34;./test&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>dependencies</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>used_as</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Stdlib&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>registered</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>registry</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;stdlib&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>requirement</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^0.0.1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>test_dependencies</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>used_as</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>registered</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>registry</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>requirement</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;^0.0.1&#34;</span></span></span></code></pre></div></div><p><code>contents</code> 以外は文書の場合と同じです．<code>contents</code> 直下には <code>library</code> というフィールドがあり，その下の <code>dependencies</code> もやはり文書の場合と同様です．ライブラリの場合は <code>test_dependencies</code> という <code>dependencies</code> によく似た項目を書くことができ，ここにはテストでのみ使用する依存パッケージが列挙されます．典型的にはテストフレームワークを提供するパッケージが記述されることになるでしょう．</p><p><code>source_directories</code> は<strong>ソースファイル</strong>を置くディレクトリを指定する項目で，ここに列挙されたディレクトリにあるファイルのうち適切な拡張子をもつものがライブラリに属するソースファイルとして認識されます．ここでは <code>./src</code> のみが指定されており，<code>./src/Calc.satyh</code> のみがソースファイルです．同様に，<code>test_directories</code> には<strong>テストファイル</strong>を置くディレクトリを指定します．ここでは <code>./test</code> のみが書かれており，<code>./test/CalcTest.satyh</code> のみがテストファイルです．</p><p><code>main_module</code> にはこのライブラリのメインモジュールを指定します．ここでは唯一のソースファイルである <code>Calc.satyh</code> がメインモジュール <code>Calc</code> を定義しており，これが指定されています．</p><p>初期化された <code>Calc.satyh</code> の内容は以下になっています：</p><div class=upcards-code-block><pre><code>module Calc :> sig
  val succ : int -> int
end = struct
  val succ n = n + 1
end</code></pre></div><p>テストは一旦置いておいて，まずはこのソースファイルを検査してみましょう．</p><h3 id=2-パッケージの依存解決-1>2. パッケージの依存解決</h3><p>文書の場合と同様に，まずはパッケージの依存解決をします：</p><div class=upcards-console-block><pre><code>$ saphe solve .
  envelope config written on '/path/to/satysfi-envelope.yaml'.
  package dependencies to solve:
  - stdlib (^0.0.1) used as Stdlib
  - testing (^0.0.1, test_only) used as Testing
  package dependency solutions:
  - stdlib 0.0.1
  - testing 0.0.1
（中略．取得処理が走る）
  lock config written on '/path/to/saphe.lock.yaml'.</code></pre></div><div class=upcards-code-block><pre><code>.
├── saphe.lock.yaml
├── saphe.yaml
├── satysfi-envelope.yaml
├── src
│   └── Calc.satyh
└── test
    └── CalcTest.satyh</code></pre></div><p>ロックファイル <code>saphe.lock.yaml</code> が生成されるのは文書の場合と同様ですが，これに加えて<strong>エンベロープファイル</strong> <code>satysfi-envelope.yaml</code> も生成されました．エンベロープファイルはSATySFi 0.1.x処理系本体が読むためのファイルであり，簡単に言えばソースファイルやテストファイルの位置がコンフィグファイルから転記されているものです．ロックファイルと同様，ユーザが読み書きすることはありませんが，バージョン管理には含めるべきものです．</p><h3 id=3-型検査を走らせる>3. 型検査を走らせる</h3><p>ライブラリの型検査はやはり <code>build</code> サブコマンドで行なわれます：</p><div class=upcards-console-block><pre><code>$ saphe build .
  deps file: '/path/to/satysfi-deps.yaml'
  parsing '/path/to/src/Calc.satyh' ...
  parsing '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/stdlib/stdlib.0.0.1/src/paper-size.satyh' ...
（中略）
  type checking '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/stdlib/stdlib.0.0.1/src/stdlib.satyh' ...
  type check passed.
 ---- ---- ---- ----
  type checking '/path/to/src/Calc.satyh' ...
  type check passed.
  deps config written on '/path/to/satysfi-deps.yaml'.</code></pre></div><p>通りました．やったぜ．</p><h3 id=4-テストを走らせる>4. テストを走らせる</h3><p>今度はユニットテストを実行してみましょう．まず，生成された <code>CalcTest.satyh</code> は以下のようなファイルです：</p><div class=upcards-code-block><pre><code>use Calc
use package Testing

module CalcTest = struct
  module IntTarget = struct
    type t = int
    val equal m n = (m == n)
    val show = arabic
  end
  module IntEquality = Testing.Equality.Make IntTarget

  #[test]
  val succ-test =
    IntEquality.assert-equal 43 (Calc.succ 42)
end</code></pre></div><p><code>use …</code> は同一パッケージ内の他のファイルが定義するモジュールを参照する指定で，Haskellの <code>import qualified …</code> と同様のものです．ここでは <code>Calc.succ</code> をテスト対象として使うために <code>Calc.satyh</code> が定義する <code>Calc</code> を参照しています．</p><p>構文的にRustとよく似ていますが，<code>#[test]</code> つきの <code>val</code> はテスト項目として扱われます．ここでは，<code>Calc.succ 42</code> の結果が <code>43</code> であることをテストする項目が書かれています．現状の <code>Testing</code> の用法はファンクタを使用した若干ややこしいものですが，とりあえず <code>IntEquality.assert-equal</code> が <code>int</code> 型の等価性をテストする函数であることだけ把握してもらえれば差し支えありません．</p><p>さて，実際にテストを走らせてみましょう：</p><div class=upcards-console-block><pre><code>$ saphe test .
  deps file: '/path/to/satysfi-deps.yaml'
  parsing '/path/to/src/Calc.satyh' ...
  parsing '/path/to/test/CalcTest.satyh' ...
  parsing '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/stdlib/stdlib.0.0.1/src/paper-size.satyh' ...
（中略）
  parsing '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/testing/testing.0.0.1/src/testing.satyg' ...
 ---- ---- ---- ----
  type checking '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/testing/testing.0.0.1/src/testing.satyg' ...
  type check passed.
（中略）
 ---- ---- ---- ----
  type checking '/path/to/src/Calc.satyh' ...
  type check passed.
 ---- ---- ---- ----
  type checking '/path/to/test/CalcTest.satyh' ...
  type check passed.
  preprocessing '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/testing/testing.0.0.1/src/testing.satyg' ...
（中略）
  preprocessing '/path/to/test/CalcTest.satyh' ...
  evaluating '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/testing/testing.0.0.1/src/testing.satyg' ...
（中略）
  evaluating '~/.saphe/packages/6f2b80e9bb7c4e8af2104999fc25dbb3/stdlib/stdlib.0.0.1/src/stdlib.satyh' ...
  evaluating '/path/to/src/Calc.satyh' ...
  evaluating '/path/to/test/CalcTest.satyh' ...
  OK: succ-test
 ---- ---- ---- ----
  all tests have passed.</code></pre></div><p>テストが通りました．やったぜ．ちなみに，失敗する場合はどうなるでしょうか？ 実装を間違ったものに変えて実行してみましょう：</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl> module Calc :&gt; sig
</span></span><span class=line><span class=cl>   val succ : int -&gt; int
</span></span><span class=line><span class=cl> end = struct
</span></span><span class=line><span class=cl><span class=gd>-  val succ n = n + 1
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+  val succ n = n + 15
</span></span></span><span class=line><span class=cl><span class=gi></span> end
</span></span></code></pre></div></div><div class=upcards-console-block><pre><code>  evaluating '/path/to/test/CalcTest.satyh' ...
! FAILED: succ-test
  expected: 43, got: 57
 ---- ---- ---- ----
! some test has failed.</code></pre></div><p>失敗が報告されました．これでスムーズにライブラリの開発ができそうですね．</p><h2 id=まとめ>まとめ</h2><p>Sapheは以下のようなコマンドで簡単に文書やライブラリを記述することのできるエコシステムです．</p><ul><li>文書を組む場合：<ol><li><code>$ saphe init document foo.saty</code> で文書ファイル <code>foo.saty</code> と<strong>コンフィグファイル</strong> <code>foo.saphe.yaml</code> を初期化し，適宜書き換える．</li><li><code>$ saphe solve foo.saty</code> で依存パッケージの解決を行ない，配置する．この結果<strong>ロックファイル</strong> <code>foo.saphe.lock.yaml</code> が書き出される．</li><li><code>$ saphe build foo.saty</code> で文書を実際に組み，<code>foo.pdf</code> を出力することができる．副産物として<strong>satysfi-depsファイル</strong> <code>foo.satysfi-deps.yaml</code> とダンプファイル <code>foo.satysfi-aux</code> が生成される．</li></ol></li><li>ライブラリを書く場合：<ol><li><code>$ saphe init library .</code> で<strong>コンフィグファイル</strong> <code>saphe.yaml</code>，ソースファイルのディレクトリ <code>src/</code>，テストファイルのディレクトリ <code>test/</code> を初期化し，適宜書き換える．</li><li><code>$ saphe solve .</code> で依存パッケージの解決を行ない，配置する．この結果<strong>ロックファイル</strong> <code>saphe.lock.yaml</code> と<strong>エンベロープファイル</strong> <code>satysfi-envelope.yaml</code> が書き出される．</li><li><code>$ saphe build .</code> でライブラリの実装を型検査できる．</li><li><code>$ saphe test .</code> でユニットテストを走らせることができる．</li></ol></li></ul><p>後編は，Sapheの内部的な設計や実装について記載する予定です．</p></div></div><script type=text/javascript>const pageNavbarHeight=50,fixedTop=30;function setTocPosition(e){const t=document.documentElement.scrollTop;t<e?tocElement.style.top=""+(fixedTop+(e-t))+"px":tocElement.style.top=""+fixedTop+"px"}const tocElement=document.getElementById("toc");tocElement!==null&&window.addEventListener("load",n=>{const t=document.getElementById("articleHeading").offsetHeight,e=t+pageNavbarHeight;window.addEventListener("scroll",t=>{setTocPosition(e)}),setTocPosition(e)})</script><script async src=https://platform.twitter.com/widgets.js></script></main><footer class="footer py-3 bg-light"><p class="footer text-center">(c) 2024 Copyright: Takashi Suwa</p></footer><script src=https://gfngfn.github.io/js/bootstrap.bundle.min.js></script>
<script src=https://gfngfn.github.io/js/masonry.pkgd.min.js></script>
<script src=https://gfngfn.github.io/js/feather.min.js></script>
<script>feather.replace()</script><script>window.addEventListener("load",function(){var t,e=document.getElementById("grid");e!==null&&(t=new Masonry(e,{itemSelector:".upcards-grid-item",horizontalOrder:!0,fitWidth:!0,gutter:0}))})</script></body></html>