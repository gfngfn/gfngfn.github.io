<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/bootstrap.min.css><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/style.css><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/chroma.css><link rel=stylesheet href=https://gfngfn.github.io/css/katex.min.css><script defer src=https://gfngfn.github.io/js/katex.min.js></script>
<script defer src=https://gfngfn.github.io/js/katex-auto-render.min.js onload=renderMathInElement(document.body)></script><title>Implementing a Virtual Machine in TeX that Runs Untyped Lambda Terms - gfnweb</title></head><body class="d-flex flex-column" style=min-height:100vh><nav id=nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class=container-fluid><a class=navbar-brand href=https://gfngfn.github.io/>gfnweb</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class=nav-item><a class=nav-link href=/><i data-feather=home></i>
Home</a></li><li class=nav-item><a class=nav-link href=/about/><i data-feather=user></i>
About</a></li><li class=nav-item><a class=nav-link href=https://github.com/gfngfn><i data-feather=github></i>
GitHub</a></li><li class=nav-item><a class=nav-link href=https://twitter.com/en_gfngfn><i data-feather=twitter></i>
Twitter</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i data-feather=file-text></i>Language</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><span class="dropdown-item disabled">English</span></li><li><a class=dropdown-item href=https://gfngfn.github.io/ja/posts/2022-05-24-tex-of-ocaml/>日本語</a></li></ul></li></ul></div></div></nav><main class="mb-auto pb-5"><div id=articleHeading class="jumbotron bg-light upcards-single-heading"><div class="mx-auto upcards-single-board"><h1 class=upcards-single-board-title>Implementing a Virtual Machine in TeX that Runs Untyped Lambda Terms</h1><div class=upcards-time-section><p class=upcards-time><time datetime=2022-05-24>May 24, 2022</time></p><p class=upcards-time>(last modified: <time datetime=2022-07-12>Jul 12, 2022</time>)</p></div><div><span style=position:relative;z-index:2><a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/tags/article>article</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/tags/tex>TeX</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/tags/latex>LaTeX</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/tags/language-processor>language processor</a></span></div><div class=mt-3><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class=twitter-share-button data-show-count=false>Tweet</a></div></div></div><div class=upcards-single-content><div class="mx-auto upcards-single-board"><p>This article introduces <code>tex_of_ocaml</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, a half-joking OSS I developed. Readers are supposed to be somewhat familiar with untyped lambda calculi.</p><p>First appearance (written in Japanese):</p><ul><li>Dec 9, 2020. <a href=https://qiita.com/gfngfn/items/b9a864e7de9e8e59a730>TeX言語で型なしλ計算を評価するVMを書いた話 - Qiita</a></li></ul><div id=toc class="upcards-toc px-3"><h3 class=mt-0>Contents</h3><nav id=TableOfContents><ul><li><a href=#summary>Summary</a></li><li><a href=#example>Example</a><ul><li><a href=#preparing-input-files>Preparing input files</a></li><li><a href=#preparing-an-output-environment>Preparing an output environment</a></li><li><a href=#compiling>Compiling</a></li><li><a href=#executing-the-produced-code>Executing the produced code</a></li></ul></li><li><a href=#what-is-the-full-expansion>What is the full expansion?</a></li><li><a href=#landins-secd-machine>Landin’s SECD machine</a></li><li><a href=#how-the-compiler-transforms-lambda-terms-into-bytecode>How the compiler transforms lambda terms into bytecode</a></li><li><a href=#how-i-implemented-the-vm-in-a-fully-expandable-manner>How I implemented the VM in a fully-expandable manner</a><ul><li><a href=#internal-representation>Internal representation</a></li><li><a href=#hacks>Hacks</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div><h2 id=summary>Summary</h2><p><code>tex_of_ocaml</code> is publicly available at the following repository:</p><p><a href=https://github.com/gfngfn/tex_of_ocaml><img src=https://gh-card.dev/repos/gfngfn/tex_of_ocaml.svg style=max-width:100%></a></p><p>(the present article refers the implementation of commit hash <code>e6e3997</code>.)</p><p>This software consists of the following two components:</p><ol><li>a small compiler implemented in Rust that transforms untyped lambda terms written in an OCaml-like syntax into TeX code, and</li><li>a back-end VM (i.e. bytecode interpreter) implemented in TeX that evaluates TeX code emitted by 1.</li></ol><p>The former one is quite a simple compiler and does not do so notable performances<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. The most notable is the latter one; it implements Landin’s <strong>SECD Machine</strong><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> where produced TeX code is evaluated by <strong>full expansion</strong> (e.g. expansion by <code>\edef</code>).</p><p>In this way, an untyped lambda calculus can be embedded into a restricted version of TeX where only fully expandable operations are permitted, and <strong>this shows that TeX is Turing-complete even if it is restricted to fully expandable operations</strong>.</p><h2 id=example>Example</h2><p>You can try the software as follows:</p><h3 id=preparing-input-files>Preparing input files</h3><p>First, use the file in the repository:</p><div class=upcards-code-block-filename-panel><pre><code>examples/example3.txt</code></pre></div><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=k>fun</span> <span class=n>f</span> <span class=o>-&gt;</span> <span class=n>f</span> <span class=o>(</span><span class=n>arabic</span> <span class=o>(</span><span class=n>add</span> <span class=n>1</span> <span class=n>x</span><span class=o>)))</span> <span class=n>42</span> <span class=o>(</span><span class=n>append</span> <span class=s2>&#34;foo&#34;</span><span class=o>)</span></span></span></code></pre></div></div><p>Here, <code>add</code> is the addition operation for natural numbers, <code>arabic</code> converts natural numbers to the string of their decimal representation, and <code>append</code> is the string concatenation.</p><h3 id=preparing-an-output-environment>Preparing an output environment</h3><p>Create a directory <code>_generated/</code> for outputs, and place <code>secd.sty</code> in it:</p><div class=upcards-console-block><pre><code>$ mkdir -p _generated
$ cp src_tex/secd.sty _generated</code></pre></div><h3 id=compiling>Compiling</h3><div class=upcards-console-block><pre><code>$ cargo run examples/example3.txt -o _generated/example3.tex</code></pre></div><p>The generated file is like the following:</p><p><div><img src=/media/tex-of-ocaml-1.png alt="The produced code" style=max-width:100%></div></p><h3 id=executing-the-produced-code>Executing the produced code</h3><p>Run the produced code:</p><div class=upcards-console-block><pre><code>$ cd _generated
$ latexmk example3.tex</code></pre></div><p>Then, a PDF file <code>_generated/example3.pdf</code> will be produced, and it looks like:</p><p><div><img src=/media/tex-of-ocaml-2.png alt="The generated PDF file saying “foo43”" style=max-width:100%></div></p><p>You can see that it says <code>"foo43"</code>, the result of evaluating <code>(fun x -> fun f -> f (arabic (add 1 x))) 42 (append "foo")</code>. As a side note, integers and booleans can also be printed as a result on PDFs, in addition to strings<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><p>More elaborate computation, such as the one that calculates the factorial of an integer, can be run<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>:</p><div class=upcards-code-block-filename-panel><pre><code>examples/factorial.txt</code></pre></div><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>fix</span> <span class=o>=</span> <span class=o>(</span><span class=k>fun</span> <span class=n>f</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>f</span> <span class=o>(</span><span class=k>fun</span> <span class=n>v</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=n>x</span> <span class=n>v</span><span class=o>))</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>f</span> <span class=o>(</span><span class=k>fun</span> <span class=n>v</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=n>x</span> <span class=n>v</span><span class=o>)))</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>fact</span> <span class=o>=</span> <span class=n>fix</span> <span class=o>(</span><span class=k>fun</span> <span class=n>f</span> <span class=o>-&gt;</span> <span class=k>fun</span> <span class=n>n</span> <span class=o>-&gt;</span> <span class=k>if</span> <span class=n>iszero</span> <span class=n>n</span> <span class=k>then</span> <span class=n>1</span> <span class=k>else</span> <span class=n>mult</span> <span class=n>n</span> <span class=o>(</span><span class=n>f</span> <span class=o>(</span><span class=n>sub</span> <span class=n>n</span> <span class=n>1</span><span class=o>)))</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=n>fact</span> <span class=n>5</span></span></span></code></pre></div></div><p>The compiler produces the following code,</p><p><div><img src=/media/tex-of-ocaml-3.png alt="The produced code" style=max-width:100%></div></p><p>and it will result in the following PDF file as intended:</p><p><div><img src=/media/tex-of-ocaml-4.png alt="The generated PDF file saying 120" style=max-width:100%></div></p><p>Hooray!</p><h2 id=what-is-the-full-expansion>What is the full expansion?</h2><p>Roughly speaking, the <strong>full expansion</strong> is a procedure of the TeX processor where only expansion (≒ term rewriting) is performed and imperative operations such as the assignment to registers are prohibited. As an example of situations where the full expansion is performed, executing <code>\edef〈Command〉{〈Tokens〉}</code> first fully expands <code>〈Tokens〉</code> and the resulting token list is used for defining how to rewrite <code>〈Command〉</code>. During the full expansion, tokens that cannot be expanded are just skipped and appended to the resulting list when encountered<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>. This makes the full expansion a bit similar to the evaluation of purely functional languages.</p><h2 id=landins-secd-machine>Landin’s SECD machine</h2><p>Although many papers or textbooks refer it, this section will briefly introduce <strong>Landin’s SECD Machine</strong><sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. It is one of the ways to implement a virtual stack machine that emulates the evaluation of programs in a lambda calculus or some language like that. As the name suggests, it is formalized as a rewriting rules on quadruples consisting of \(S\) (Stack), \(E\) (Environment), \(C\) (Code), and \(D\) (Dump). These metavariables are defined by:</p><div class=upcards-math-block><p>\[\begin{align*}
&\text{stacks} & S &::= [V]^{\ast}
\\
&\text{environments} & E &::= [V]^{\ast}
\\
&\text{code} & C &::= [I]^{\ast}
\\
&\text{dumps} & D &::= [(C, E)]^{\ast}
\\
&\text{values} & V &::= c\ |\ \langle C, E\rangle
\end{align*}\]</p></div><p>where \([X]^{\ast}\) ranges over (possibly empty) finite sequences of \(X\), and \(c\) ranges over the set of constants such as integers and Boolean values. The metavariable \(I\) ranges over <strong>instructions</strong> defined as follows<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>:</p><div class=upcards-math-block><p>\[\begin{align*}
&\text{instructions} & I &::=
\\
&&&|\ \mathrm{Access}(i)
\\
&&&|\ \mathrm{Closure}(C)
\\
&&&|\ \mathrm{Apply}
\\
&&&|\ \mathrm{Return}
\\
&&&|\ \mathrm{Const}(c)
\\
&&&|\ \mathrm{Prim}(p)
\end{align*}\]</p></div><p>Here, \(i\) ranges over the set of natural numbers<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> called <strong>indices</strong>. In operational terms, as described below, indices correspond to variables in lambda calculi. The metavariable \(p\) stands for primitive operations over constants such as integer addition \(+\) or the logical conjunction \(\land\). Each primitive has its arity (i.e. how many arguments it takes), and we denote \(p\)’s arity by \(\mathrm{arity}(p)\) and the result of applying \(p\) to \(V_1, \ldots, V_n\) by \(p(V_1, \ldots, V_n)\) (e.g. \(+(42, 57) = 99\)).</p><p>Intuitively, \(S\) is a last-in first-out stack of values representing intermediate results of computation; only the topmost value can be popped from \(S\), and new values can be pushed only on the top of \(S\). An environment \(E\) is a sequence that maps indices to their corresponding values. Unlike stacks, values in environments can be accessed randomly by indices. Code \(C\) is a sequence of instructions, and each instruction in code designates what operation should be executed next. A dump \(D\) is a stack of values and environments saved during function calls.</p><p>The following rewriting rules formalize the intuition of operations described above. On evaluating code \(C\), the initial state is set to \((\epsilon, \epsilon, C, \epsilon)\), and will be repeatedly rewritten by the following rules:</p><div class=upcards-math-block><p>\[\begin{align*}
(S, E, \mathrm{Access}(i) \cdot C, D) &\longrightarrow
(E[i] \cdot S, E, C, D)
\\
(S, E, \mathrm{Closure}(C') \cdot C, D) &\longrightarrow
(\langle C', E\rangle \cdot S, E, C, D)
\\
(V \cdot \langle C', E'\rangle \cdot S, E, \mathrm{Apply} \cdot C, D) &\longrightarrow
(S, V \cdot E', C', (C, E) \cdot D)
\\
(S, E, \mathrm{Return} \cdot C, (C', E') \cdot D) &\longrightarrow
(S, E', C', D)
\\
(S, E, \mathrm{Const}(c) \cdot C, D) &\longrightarrow
(c \cdot S, E, C, D)
\\
(V_n \cdot \cdots \cdot V_1 \cdot S, E, \mathrm{Prim}(p) \cdot C, D) &\longrightarrow
(p(V_1, \ldots, V_n) \cdot S, E, C, D)
\\
&\phantom{\longrightarrow}\quad(\text{where}\ n = \mathrm{arity}(p))
\end{align*}\]</p></div><p>Here, \(E[i]\) is “the \(i\)-th element of \(E\)” (where \(i\) is a zero-based index), and can be defined as follows:</p><div class=upcards-math-block><p>\[\begin{align*}
(V \cdot E)[0] &:= V
\\
(V \cdot E)[j + 1] &:= E[j]
\end{align*}\]</p></div><p>Values of the form \(\langle C, E\rangle\) are called <strong>closures</strong>. A closure represents a pair of “suspended computation” \(C\) and an environment \(E\) for it. An instruction of the form \(\mathrm{Closure}(C)\) makes a closure from \(C\) and the environment \(E\) at that time and pushes it to the stack. The instruction \(\mathrm{Apply}\) corresponds to the function application; it pops from the stack two values, \(V_1\) and \(V_2\), and then applies \(V_2\), which is expected to be a closure, to \(V_1\).</p><p>The result of computation \(V\) can be obtained finally when the rewriting terminates at a state of the form \((V, E, \epsilon, \epsilon)\). If the rewriting cannot progress any more and the state is not of that form, then it turns out to be an invalid computation (roughly corresponds to a dynamic error of untyped languages). There is also a possibility that the rewriting never halts; this corresponds to so-called an infinite loop.</p><p>The formalization described so far is what I implemented by using TeX as I discuss below.</p><h2 id=how-the-compiler-transforms-lambda-terms-into-bytecode>How the compiler transforms lambda terms into bytecode</h2><p>Code \(C\) that forms the initial state \((\epsilon, \epsilon, C, \epsilon)\) of the SECD Machine will be produced by a compiler from programs written by users. The compilation has the following two steps:</p><ol><li>Receives a program written by the user and turn it into the equivalent <strong>de Bruijn representation</strong>.</li><li>Converts the de Bruijn term (gained at 1) into code for the SECD Machine.</li></ol><p>The first step is easy; it just replaces named variables in the program with natural numbers called <strong>de Bruijn indices</strong>. The following \(e\) and \(t\) define the syntax of lambda terms and that of de Brujin representations, respectively:</p><div class=upcards-math-block><p>\[\begin{align*}
e &::= x\ |\ \lambda x.\ e\ |\ e\ e\ |\ c\ |\ p([e]^{\ast})
\\
t &::= i\ |\ \lambda.\ t\ |\ t\ t\ |\ c\ |\ p([t]^{\ast})
\end{align*}\]</p></div><p>Here \(i\) ranges over de Bruijn indices, every occurrence of which stands for “how many λ symbols are between the variable occurrence and the λ symbol that binds it”. You can probably see what the conversion is like to be by the following examples:</p><ul><li>\((\lambda x.\ \lambda y.\ x\ y)\) ↦ \((\lambda.\ \lambda.\ 1\ 0)\)</li><li>\((\lambda x.\ \lambda y.\ (\lambda z.\ z\ x)\ y)\) ↦ \((\lambda.\ \lambda.\ (\lambda.\ 0\ 2)\ 0)\)</li></ul><p>The following rules for converting each lambda term \(e\) into its corresponding de Bruijn representation \(\mathrm{dB}(e)\) generalize the examples above:</p><div class=upcards-math-block><p>\[\begin{align*}
\mathrm{dB}(e) &:= \mathrm{dB}(\epsilon, e)
\\
\mathrm{dB}(w, x) &:=
\mathrm{Index}(w, x)
\\
\mathrm{dB}(w, \lambda x.\ e) &:=
\lambda.\ \mathrm{dB}(x \cdot w, e)
\\
\mathrm{dB}(w, e_1\ e_2) &:=
\mathrm{dB}(w, e_1)\ \mathrm{dB}(w, e_2)
\\
\mathrm{dB}(w, c) &:=
c
\\
\mathrm{dB}(w, p(e_1, \ldots, e_n)) &:=
p(\mathrm{dB}(w, e_1), \ldots, \mathrm{dB}(w, e_n))
\\
\mathrm{Index}(y \cdot w, x) &:= 1 + \mathrm{Index}(w, x)\quad(\text{if}\ y \neq x)
\\
\mathrm{Index}(x \cdot w, x) &:= 0
\end{align*}\]</p></div><p>The second step is also not so complicated; from a de Bruijn representation \(t\), one can produce the resulting bytecode \(\lfloor t\rfloor\) by the following definition:</p><div class=upcards-math-block><p>\[\begin{align*}
\lfloor i\rfloor &:=
\mathrm{Access}(i)
\\
\lfloor \lambda.\ t\rfloor &:=
\mathrm{Closure}(\lfloor t\rfloor \cdot \mathrm{Return})
\\
\lfloor t_1\ t_2\rfloor &:=
\lfloor t_1\rfloor \cdot \lfloor t_2\rfloor \cdot \mathrm{Apply}
\\
\lfloor c \rfloor &:=
\mathrm{Const}(c)
\\
\lfloor p(t_1, \ldots, p_n) \rfloor &:=
\lfloor t_1\rfloor \cdot \cdots \cdot \lfloor t_n\rfloor \cdot \mathrm{Prim}(p)
\end{align*}\]</p></div><p>The above is the procedure of converting a lambda term \(e\) into bytecode \(C := \lfloor\mathrm{dB}(e)\rfloor\) for the SECD Machine.</p><h2 id=how-i-implemented-the-vm-in-a-fully-expandable-manner>How I implemented the VM in a fully-expandable manner</h2><p>This section refers the core part of this article, i.e., how to implement the SECD Machine in TeX in a fully expandable manner. It does not really require dazzling virtuosity as long as you are familiar with the SECD Machine and how to control expansion in TeX. The following is the implementation, and a lot of comments around the definitions in it might help you read it (unlike typical cases where you read programs written in TeX only to find they are almost unreadable for humans other than the original developer):</p><ul><li><a href=https://github.com/gfngfn/tex_of_ocaml/blob/e3f146e9d76f898a81e3ef62555a2413c1d26266/src_tex/secd.sty>secd.sty at e3f146e… · gfngfn/tex_of_ocaml · GitHub</a></li></ul><p>In the program above, the definition of the SECD Machine ends at line 370, and all definitions after that are for primitive operations (like integer addition or string concatenation). The essential point in the definition of the SECD Machine is <code>\secd@Run</code>. Occurring a token list <code>\secd@Run{〈S〉}{〈E〉}{〈C〉}{〈D〉}</code> corresponds to the fact that the quadruple \((S, E, C, D)\) appears in the rewriting sequence based on the formal definition. Expanding a token list of the form <code>\secd@Run{〈S〉}{〈E〉}{〈C〉}{〈D〉}</code> leads to another list of that form, and eventually halts when \(C\) is empty (if all goes well).</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-tex data-lang=tex><span class=line><span class=cl><span class=k>\def\secd</span>@Run#1#2#3#4<span class=nb>{</span><span class=c>%
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>%% #1 : stack
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>%% #2 : environment
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>%% #3 : code
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>%% #4 : dump
</span></span></span><span class=line><span class=cl><span class=c></span>  ...
</span></span><span class=line><span class=cl><span class=nb>}</span></span></span></code></pre></div></div><h3 id=internal-representation>Internal representation</h3><p>Although comments in the implementation above describe how to represent values internally, the main feature of the representation are also noted here.</p><p>First, \(S\), \(E\), \(C\), and \(D\) are easy; they just list their elements:</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-tex data-lang=tex><span class=line><span class=cl>〈Stack〉 ::= ［〈Value〉］
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>〈Environment〉 ::= ［〈Value〉］
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>〈Code〉 ::= ［〈Instruction〉］
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>〈Dump〉 ::= ［<span class=k>\secd</span>@DUMP<span class=nb>{</span>〈Code〉<span class=nb>}{</span>〈Environment〉<span class=nb>}</span>］</span></span></code></pre></div></div><p>where <code>［X］</code> ranges over (possibly empty) finite sequence of <code>X</code>.</p><p>Values have the following format: a control sequence at the beginning that serves as a tag for distinguishing which kind of constant the value is, the control sequence <code>\secd@ENDVAL</code> at the end, and an encoded constant in between:</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-tex data-lang=tex><span class=line><span class=cl>〈Value〉 ::=
</span></span><span class=line><span class=cl>   | <span class=k>\secd</span>@CLOS<span class=nb>{</span>〈Code〉<span class=nb>}{</span>〈Environment〉<span class=nb>}</span><span class=k>\secd</span>@ENDVAL
</span></span><span class=line><span class=cl>   | <span class=k>\secd</span>@INT<span class=nb>{</span>〈Number〉<span class=nb>}</span><span class=k>\secd</span>@ENDVAL
</span></span><span class=line><span class=cl>   | <span class=k>\secd</span>@BOOL<span class=nb>{</span>〈Bool〉<span class=nb>}</span><span class=k>\secd</span>@ENDVAL
</span></span><span class=line><span class=cl>   | <span class=k>\secd</span>@STRING<span class=nb>{</span>〈String〉<span class=nb>}</span><span class=k>\secd</span>@ENDVAL</span></span></code></pre></div></div><p>It is actually important that the tags are unexpandable; specifically, they are made equal to <code>\relax</code> by <code>\let</code>, and thus they stop expansion invoked by <code>\romannumeral</code>.</p><p>Instructions also have simple formats; all of the formats have a single tag and exactly one argument:</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-tex data-lang=tex><span class=line><span class=cl>〈Instruction〉 ::=
</span></span><span class=line><span class=cl>  | <span class=k>\secd</span>@ACCESS<span class=nb>{</span>〈Index〉<span class=nb>}</span>
</span></span><span class=line><span class=cl>  | <span class=k>\secd</span>@CLOSURE<span class=nb>{</span>〈Code〉<span class=nb>}</span>
</span></span><span class=line><span class=cl>  | <span class=k>\secd</span>@APPLY<span class=nb>{}</span>
</span></span><span class=line><span class=cl>  | <span class=k>\secd</span>@RETURN<span class=nb>{}</span>
</span></span><span class=line><span class=cl>  | <span class=k>\secd</span>@CONST<span class=nb>{</span>〈Value〉<span class=nb>}</span>
</span></span><span class=line><span class=cl>  | <span class=k>\secd</span>@PRIM<span class=nb>{</span>〈PrimitiveCommand〉<span class=nb>}</span></span></span></code></pre></div></div><p>De Bruijn indices are represented by the number of <code>*</code>s in a row:</p><div class=upcards-code-block><pre><code>〈Index〉 ::= ［*］</code></pre></div><p>Since de Bruijn indices are only statically determined and at most in proportion to the size of the program, such a unary numeral system suffices for representation. However, the current implementation adopts a similar system for natural numbers as well, which are dynamically calculated; natural numbers are represented by the number of <code>o</code>s in a row:</p><div class=upcards-code-block><pre><code>〈Number〉 ::= ［o］

〈Bool〉 ::= T | F</code></pre></div><p>For instance, if you have to handle five hundred million as an intermediate result of calculation, it will be represented by <code>o</code>s’ sequence of length 500,000,000. This way of representation never scales, of course. Although we can probably represent natural numbers in the binary numeral system, I adopted the unary one because it seems to make concise the implementation of arithmetic operations, conversion to decimal representations, etc. I would like to replace the unary representations with binary ones if I decide to develop this software more seriously, but it is not probable that I will have a strong desire to develop this software in the future.</p><h3 id=hacks>Hacks</h3><p>This section explains tricks <code>tex_of_ocaml</code> uses to those who are quite familiar with techniques about expansion control of TeX.</p><h4 id=promoting-expansion-using-expandafter-and-romannumeral>Promoting expansion using <code>\expandafter</code> and <code>\romannumeral</code></h4><p>Some parts in the implementation use the so-called <strong><code>\romannumeral</code> trick</strong> for:</p><ul><li>accessing a value in an environment \(E\) by an index \(i\),</li><li>adding to the stack a value produced by primitive operations such as integer addition, etc.</li></ul><h4 id=the-hop-trick>The <code>\hop</code> trick</h4><p>The use of the control sequences <code>\secd@Hop</code>, <code>\secd@Then</code>, and <code>\secd@HopOr</code> in the implementation corresponds to the ordinary <strong><code>\hop</code> trick</strong>. Although there are some other tricks than the <code>\hop</code> trick that can be used for escaping from a conditional branch, the <code>\hop</code> trick is especially useful in that it can be generalized to <code>\ifcase</code>.</p><h2 id=conclusion>Conclusion</h2><p>Although it is a rather crude introduction, this article shows that the untyped lambda terms can be evaluated with the call-by-value strategy in TeX’s full expansion circumstance. Only a concrete example of factorial uses it, but the software can also handle conditional branching, which have to be added as a language feature under the call-by-value semantics.</p><p>Although <code>tex_of_ocaml</code> is not particularly practical at this point, it is significant that we were able to briefly demonstrate that TeX as a programming language is Turing-complete even when limited to the full expansion. If we want to make it more practical, we could introduce an FFI mechanism to allow TeX/LaTeX code to call programs implemented in untyped lambda calculi.</p><ul><li>Possible question 1: Is there anything nice about implementing a VM that can run under TeX’s full expansion circumstance?<ul><li>Answer: I don’t know. I’m just glad that it’s implemented.</li></ul></li><li>Possible question 2: Come to think of it, didn’t you write the compiler itself in TeX?<ul><li>Answer: I didn’t, because my life is too short to do that.</li></ul></li><li>Possible question 3: Haven’t you already wasted your time when you wrote this software?<ul><li>Answer: Yes.</li></ul></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>As OCaml users can easily find, the name originates from <code>js_of_ocaml</code>. Probably <code>js_of_ocaml</code> itself originates from function names like <code>string_of_int</code> given by the standard library of OCaml, though.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>I took writing this compiler as an opportunity of learning Rust. The code is far from sophisticated thereby.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Peter J. Landin. The Mechanical Evaluation of Expression. <em>Computer Journal</em>, 6, pp.308–320. 1964.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Closures are printed as <code>(closure)</code>. This is analogous to the state where OCaml REPL prints <code>&lt;fun></code> on stdout for closures.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>The function <code>fix</code> in this program is called the <strong>fixed-point operator</strong>. Since <code>tex_of_ocaml</code> is untyped, one can express recursion simply by using <code>fix</code> without introducing a language feature like <code>let rec</code>.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Giving a more detailed explanation about how the full expansion for those who are not familiar with TeX’s ordinary expansion is extremely difficult, but I will try it here a little: In TeX, tokens are classified into expandable ones and unexpandable ones. The latter category includes ordinary alphanumeric letters or symbols for outputs, and some of the primitive tokens, among which imperative ones such as assignment operation for registers are typical. When a TeX processor encounters an unexpandable token, it just skips the token as if the token were a part of the output (without executing any imperative operation even if the token stands for such an operation).&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>In realistic situations, more instructions are added depending on the features the programming language has.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>A natural number is, of cource, an integer greater than <em>or equal to</em> zero.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div><script type=text/javascript>const pageNavbarHeight=50,fixedTop=30;function setTocPosition(e){const t=document.documentElement.scrollTop;t<e?tocElement.style.top=""+(fixedTop+(e-t))+"px":tocElement.style.top=""+fixedTop+"px"}const tocElement=document.getElementById("toc");tocElement!==null&&window.addEventListener("load",n=>{const t=document.getElementById("articleHeading").offsetHeight,e=t+pageNavbarHeight;window.addEventListener("scroll",t=>{setTocPosition(e)}),setTocPosition(e)})</script><script async src=https://platform.twitter.com/widgets.js></script></main><footer class="footer py-3 bg-light"><p class="footer text-center">(c) 2023 Copyright: T. Suwa</p></footer><script src=https://gfngfn.github.io/js/bootstrap.bundle.min.js></script>
<script src=https://gfngfn.github.io/js/masonry.pkgd.min.js></script>
<script src=https://gfngfn.github.io/js/feather.min.js></script>
<script>feather.replace()</script><script>window.addEventListener("load",function(){var t,e=document.getElementById("grid");e!==null&&(t=new Masonry(e,{itemSelector:".upcards-grid-item",horizontalOrder:!0,fitWidth:!0,gutter:0}))})</script></body></html>