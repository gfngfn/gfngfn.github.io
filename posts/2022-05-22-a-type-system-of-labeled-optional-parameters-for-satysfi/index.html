<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/bootstrap.min.css><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/style.css><link rel=stylesheet type=text/css href=https://gfngfn.github.io/css/chroma.css><title>A Type System of Labeled Optional Parameters for SATySFi - gfnweb</title></head><body class="d-flex flex-column" style=min-height:100vh><nav id=nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class=container-fluid><a class=navbar-brand href=https://gfngfn.github.io/>gfnweb</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class=nav-item><a class=nav-link href=/><i data-feather=home></i>
Home</a></li><li class=nav-item><a class=nav-link href=/about/><i data-feather=user></i>
About</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i data-feather=file-text></i>Language</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><span class="dropdown-item disabled">English</span></li><li><a class=dropdown-item href=https://gfngfn.github.io/ja/posts/2022-05-22-a-type-system-of-labeled-optional-parameters-for-satysfi/>日本語</a></li></ul></li></ul></div></div></nav><main class="mb-auto pb-5"><div class="jumbotron bg-light upcards-single-heading"><div class="mx-auto upcards-single-board"><h1 class=upcards-single-board-title>A Type System of Labeled Optional Parameters for SATySFi</h1><div class=upcards-time-section><p class=upcards-time><time datetime=2022-05-22>May 22, 2022</time></p></div><div><span style=position:relative;z-index:2><a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/tags/article>article</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/tags/satysfi>SATySFi</a>
<a class="btn btn-sm btn-outline-dark tag-btn upcards-tag-button" href=https://gfngfn.github.io/tags/type-system>type system</a></span></div></div></div><div class=upcards-single-content><div class="mx-auto upcards-single-board"><p>I am in the process of changing the language design for SATySFi v0.1.0 about optional parameters. It will be a breaking change (i.e. not backward compatible with SATySFi v0.0.x), and I will introduce it here.</p><p>First appearance:</p><ul><li>Dec 30, 2021. <a href=https://github.com/gfngfn/SATySFi/wiki/%E3%83%A9%E3%83%99%E3%83%AB%E3%81%A4%E3%81%8D%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E5%BC%95%E6%95%B0%E3%81%AE%E5%9E%8B%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0>SATySFi Wiki</a> (written in Japanese)</li></ul><h2 id=motivation-of-the-reformulation>Motivation of the Reformulation</h2><p>Originally, SATySFi v0.0.x has a mechanism of non-labeled optional parameters/arguments, and it can be used with <code>?:</code> like the following:</p><div class=upcards-code-block><pre><code>+section?:(`sec:sample`)?:(`Sample`){Sample}<
  ... the contents of the section ...
></code></pre></div><p>Optional arguments does not have a label, and thereby are distinguished by their order. In the example above, the first optional argument is a tag for the cross reference, and the second one is for the title of the section displayed in the Outline of the resulting PDF file. As well as commands, ordinary functions can take optional parameters:</p><div class=upcards-code-block><pre><code>let succ ?diff-opt n =
  match diff-opt with
  | Some(d) -> n + d
  | None    -> n + 1
in
(succ 42, succ ?:57 42)
  % --> (43, 99)</code></pre></div><p>The reason why a mechanism of non-labeled optional parameters was adopted is that the language design was inspired by that of LaTeX, where optional parameters are conventionally given in a non-labeled manner:</p><div class=upcards-code-block><div class=highlight><pre tabindex=0 class=chroma><code class=language-latex data-lang=latex><span class=line><span class=cl><span class=k>\parbox</span><span class=na>[c]</span><span class=nb>{</span>6em<span class=nb>}{</span>…<span class=nb>}</span>, <span class=s>$</span><span class=nv>\sqrt</span><span class=o>[</span><span class=m>3</span><span class=o>]</span><span class=nb>{</span><span class=m>2</span><span class=nb>}</span><span class=s>$</span></span></span></code></pre></div></div><p>It has, however, lead to the following significant inconveniences, partly because there came to be more use cases of optional parameters than expected:</p><ul><li>Since optional arguments are distinguished only by their order, in many cases where you use or read functions that have optional parameters it is difficult to comprehend in what order each argument should be specified.</li><li>When you want to omit a former parameter and to give an argument to a latter one, you have to do some cumbersome workaround–to “explicitly omit” the former one by <code>?*</code>.<ul><li>Example:<div class=upcards-code-block><pre><code>+section?*?:(`Sample`){Sample}<
  ... the contents of the section ...
></code></pre></div></li></ul></li></ul><p>To remove this kind of burden, I came upon the idea of reformulating the mechanism of optional parameters into labeled one where one can give optional arguments like the following:</p><div class=upcards-code-block><pre><code>+section?(ref = `sec:sample`, outline = `Sample`){Sample}<
  ... the contents of the section ...
></code></pre></div><p>As you can see, optional arguments can be specified by <code>?(label1 = arg1, …, labelN = argN)</code>. You can omit the whole part <code>?(...)</code> if you don’t want to specify any optional argument. Ordinary functions can take labeled optional parameters as well:</p><div class=upcards-code-block><pre><code>let succ ?(diff = diff-opt) n =
  match diff-opt with
  | Some(d) -> n + d
  | None    -> n + 1
  end
in
(succ 42, succ ?(diff = 57) 42)</code></pre></div><p>This will bring the following benefits:</p><ul><li>Since optional arguments are labeled, it is easy to read for what purpose each argument is specified.</li><li>Since optional arguments can be in a ramdom order, you don’t have to do any workaround like the one using <code>?*</code>.</li><li>Because types of optional parameters/arguments can be statically inferred as usual, type errors will be reported when one gives an argument of a type incompatible to the expected one.</li></ul><p>It seems also good to me that one can give default values as follows when defining optional parameters:</p><div class=upcards-code-block><pre><code>let succ ?(diff = d = 1) n =
  n + d
in
(succ 42, succ ?(diff = 57) 42)</code></pre></div><h2 id=the-detail-of-the-type-system>The Detail of the Type System</h2><h3 id=extension-to-function-types-function-abstractions-and-function-applications>Extension to Function Types, Function Abstractions, and Function Applications</h3><p>Function types <code>τ -> τ</code> will be extended to the following form:</p><div class=upcards-code-block><pre><code>τ ::=
  …
  | ?(l : τ, …, l : τ) τ -> τ</code></pre></div><p>The traditional form <code>τ1 -> τ2</code> is equivalent to <code>?() τ1 -> τ2</code>. Although function types will actually take a more general form explained later, it is sufficient for now to display the form above.</p><p>(Side note: function types with non-labeled optional parameters in SATySFi v0.0.x have the form <code>τ ?-> … τ ?-> τ -> τ</code>.)</p><p>Function abstractions and applications will also be extended like the following:</p><div class=upcards-code-block><pre><code>e ::=
  …
  | fun ?(l = x, …, l = x) x -> e
  | e ?(l = e, …, l = e) e</code></pre></div><p>Similarly to the case of function types, <code>fun x -> e</code> and <code>e1 e2</code> are equivalent to <code>fun ?() x -> e</code> and <code>e1 ?() e2</code>, respectively. Binders in abstractions can also take type annotations, but it is omitted for clarity here.</p><p>The derivation rule for typing function applications is concise, like the following:</p><div class=upcards-code-block><pre><code>Γ, x_1 : option τ_1, …, x_n : option τ_n, x : τ' ⊢ e : τ
-----------------------------------------------------------------------------
Γ ⊢ fun ?(l_1 = x_1, …, l_n = x_n) x -> e : ?(l_1 : τ_1, …, l_n : τ_n) τ' -> τ</code></pre></div><p>The rule is very straightforward except that it should be noted that bound variables are of type <code>option τ_i</code>, not <code>τ_i</code> in <code>e</code>.</p><p>The derivation rule for function abstractions looks a bit more complicated, but is not so complex in meaning:</p><div class=upcards-code-block><pre><code>Γ ⊢ e : ?(l_1 : τ_1, …, l_n : τ_n) τ' -> τ
Γ ⊢ e_k : τ_(j_k)  (for each k ∈ {1, …, m})
Γ ⊢ e' : τ'
-----------------------------------------------
Γ ⊢ e ?(l_(j_1) = e_1, …, l_(j_m) = e_m) e' : τ</code></pre></div><h3 id=polymorphism>Polymorphism</h3><p>The basics of the newly introduced type system has been described so far, but an additional trick is needed actually; optional parameters require a kind of polymorphism.</p><p>Consider the following example: what kind of type should be assigned to higher-order functions like the following?</p><div class=upcards-code-block><pre><code>let use_optional(f) = f ?(foo = 42, 57) + 1</code></pre></div><p>Specifically, what type should <code>f</code> be of? Although you may suppose that <code>f</code> has a type like <code>?(foo : int) int -> int</code>, there is a possibility that <code>f</code> can take another optional parameter <code>bar</code> but that no argument is speficied for <code>bar</code> here. Handling such kind of constraints needs polymorphic types for optional parameters.</p><p>In order to express such polymorphism, the type system of optional parameters for SATySFi v0.1.0 leverages a kind of <strong>row polymorphism</strong> [1]. This may perhaps be of my own devising because I haven’t seen any paper or implementation that use a similar formalization, but it is not so particularly ingenious and has not been proved to fulfill type safety yet.</p><p>The basic concept of the type system is to regard whole optional arguments in a function application as a <strong>row</strong>. Rows are typically used for typing records, but are also utilized for typing optional parameters/arguments here by giving the following syntax:</p><div class=upcards-code-block><pre><code>τ ::=
  …
  | ?(r) τ -> τ

r ::=
  | l : τ, r
  | *
  | ρ</code></pre></div><p>The metavariable <code>r</code> represents a row, and <code>ρ</code> ranges over the set of <strong>row variables</strong>. The symbol <code>*</code> stands for the empty row, and <code>l : τ, r</code> is the row produced by appending <code>l : τ</code> to the row <code>r</code>. The aforementioned form of function type <code>?(l_1 : τ_1, …, l_n : τ_n) τ' -> τ</code> is actually the special case of function types having a row of the form <code>l_1 : τ_1, …, l_n : τ_n, *</code>.</p><p>By using this type system, one can assign to <code>use_optional</code> the following type:</p><div class=upcards-code-block><pre><code>use_optional : ∀ρ :: Row {foo}. ?(foo : int, ρ) int -> int</code></pre></div><p>where the kind <code>Row L</code> with a label set <code>L</code> is the one for rows that do not contain any label in <code>L</code>. Namely, the universal quantification in the type above means that <code>ρ</code> can be instantiated to any row that does not have <code>foo</code> as a label. In this fashion, it will be verified that <code>f</code>, the first parameter of <code>use_optional</code>, must be able to take a parameter of type <code>int</code> labeled by <code>foo</code>, but no constraint is imposed on the capability of taking the other labels.</p><p>This mechanism has already been basically implemented in <a href=https://github.com/gfngfn/SATySFi/pull/294>a PR for developing SATySFi v0.1.0</a>, and been verified to work fine at least for some use cases.</p><h2 id=conclusion>Conclusion</h2><p>This article has introduced a mechanism of labeled optional parameters designed and implemented for SATySFi v0.1.0, and explained that it is based on the row polymorphism.</p><h2 id=references>References</h2><ol><li>Benedict R. Gaster and Mark P. Jones. <a href=https://web.cecs.pdx.edu/~mpj/pubs/96-3.pdf>A polymorphic type system for extensible records and variants</a>, 1996.</li></ol></div></div></main><footer class="footer py-3 bg-light"><p class="footer text-center">(c) 2022 Copyright: T. Suwa</p></footer><script src=https://gfngfn.github.io/js/bootstrap.bundle.min.js></script>
<script src=https://gfngfn.github.io/js/masonry.pkgd.min.js></script>
<script src=https://gfngfn.github.io/js/feather.min.js></script>
<script>feather.replace()</script><script>window.addEventListener("load",function(){var t,e=document.getElementById("grid");e!==null&&(t=new Masonry(e,{itemSelector:".upcards-grid-item",horizontalOrder:!0,fitWidth:!0,gutter:0}))})</script></body></html>